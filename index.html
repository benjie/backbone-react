<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      code .lolight,
      code .lolight * {
        color: #aaa !important;
      }
      code .hilight,
      code .hilight * {
        color: green !important;
      }
    </style>
  </head>
  <body>
    <script id="source" language="remarkjs"><!--


# Leveraging React's Awesomeness in a Legacy Backbone App
## By Jof Arnold and Benjie Gillam
## Timecounts.org

---

# CoffeeScript

- We're using JS in this presentation to reach more people.
- But we're lazy, so if you see `@` in the text, replace it in your head with `this.`
- e.g. `@listenTo()` becomes `this.listenTo()`
- If you code lots of JS and you don't know CoffeeScript you're crazy

---

# History

---

## Separate API and frontend

- Ensures powerful API
- Strong separation of data from layout
- Easier to secure/define permissions
- Obvious boundaries for concerns

---

## Node.js Frontend

- Allows for Isomorphism
- Very familiar with Backbone apps
- Both server and client speak to same RESTful API
- Node well suited to this workflow (mostly waiting for API)

---

## Single-page style app

- Fast page transitions
- Often no need to refetch data
- Less data transfer for customers

---

## Research isomorphic frameworks

- Spike Brehm has some very interesting talks.
- Spike's made a proof of concept called Rendr.
- AirBnB are using it in production!
- Decide to give it a go

---

## Use AirBnB's Rendr - Awesome!

- Isomorphic
- Looks like it solves the issues
- Initial proof of concept very quick
- I can grok then concepts behind it

---

## Use AirBnB's Rendr - Good...

- A few rough edges become apparent
- Fight the framework (I'm differently opinionated)
- Many monkey patches

---

## Use AirBnB's Rendr - Urgh...

- Handlebars templates really slow us down
- Storing state in DOM
- Re-rendering subtrees of views with handlebars helpers
- Lots of fragile jQuery code to keep view in sync
- Iteration speed drops heavily
- Simple changes start to look mammoth

---

# There must be a better way?

---

# REACT!
## The new hotness, and now it's stable!
### Hey, Jof, I reckon we can integrate React view by view without having to re-architect everything...

---

## Initial proof of concept took less than a day

And most of that was figuring out various Rendr internals we'd need to monkey patch.

It'll be **much** faster for you if you just use Backbone on the frontend!

---

## Let us show you how

---

# WARNING

This is **not** the true React (Flux) way of doing things. This is a quick method of utilising React and its magic in your Backbone project without having to rebuild everything.

<img src="http://i.imgur.com/Mvzj4Mc.gif">

---

# A simple Backbone App

- Home:
  - generates a random number when you click
  - lets you store notes in a textarea
- About: static content

<iframe src="demos/backbone/index.html" style="width: 100%; height: 18em"></iframe>

---

## Router

```js
var AppRouter = Backbone.Router.extend({
  routes: {
    '': 'homeRoute',
    'about': 'aboutRoute'
  },
  initialize: function() {
    this.$rootEl = $("#content");
    this.rootEl = this.$rootEl[0];
  },
  setView: function(view) {
    if (this.view) {
      this.view.remove();
    }
    this.view = view;
    this.view.render();
    this.$rootEl.append(this.view.el);
  },
  homeRoute: function() {
    this.setView(new HomeView())
  },
  aboutRoute: function() {
    this.setView(new AboutView())
  }
});
```

---

## AboutView

```js
var AboutView = Backbone.View.extend({
  template: _.template('<h1>About</h1><p>' +
    '<img src="http://www.reactiongifs.com/r/1gjdAX7.gif"></p>'),

  render: function() {
    this.$el.html(this.template());
  }
});
```

---

## HomeView

```js
var HomeView = Backbone.View.extend({
  template: _.template('<h1>Hello World!</h1>' +
    '<p>Random number: <span><%- number %></span> (click for another)</p>' +
    '<textarea>Notes...</textarea>'),

  events: {
    'click p': 'newNumber'
  },

  randomNumber: function() {
    return Math.round(Math.random() * 100)
  },

  newNumber: function(e) {
    this.$("span").html(this.randomNumber());
  },

  render: function() {
    this.$el.html(this.template({
      number: this.randomNumber()
    }));
  }
});
```
---

[Screenshot of Home] [Screenshot of About]

---

## Adding React support to your router

<pre><code class="javascript"><span class="lolight">AppRouter = Backbone.Router.extend({</span>
<span class="lolight">  //...</span>

<span class="lolight">  setView: function(view) {</span>
<span class="lolight">    if (this.view) {</span>
<span class="hilight">      if (this.view instanceof Backbone.View) {</span>
<span class="lolight">        this.view.remove();</span>
<span class="hilight">      } else {</span>
<span class="hilight">        React.unmountComponentAtNode(this.rootEl);</span>
<span class="hilight">      }</span>
<span class="lolight">    }</span>

<span class="lolight">    this.view = view;</span>
<span class="hilight">    if (this.view instanceof Backbone.View) {</span>
<span class="lolight">      this.view.render();</span>
<span class="lolight">      this.$rootEl.append(this.view.el);</span>
<span class="hilight">    } else {</span>
<span class="hilight">      React.render(this.view, this.rootEl);</span>
<span class="hilight">    }</span>
<span class="lolight">  },</span>

<span class="lolight">  //...</span>
<span class="lolight">});</span>
</code></pre>

---

## Converting HomeView to React

<pre><code class="javascript"><span class="hilight">var DOM = React.DOM;</span>
<span class="hilight">var HomeView = React.createClass({</span>
<span class="hilight">  displayName: "HomeView",</span>
<span class="hilight">  getInitialState: function() {</span>
<span class="hilight">    return {</span>
<span class="hilight">      randomNumber: this.randomNumber()</span>
<span class="hilight">    };</span>
<span class="hilight">  },</span>
<span class="lolight">  randomNumber: function() {</span>
<span class="lolight">    return Math.round(Math.random() * 100);</span>
<span class="lolight">  },</span>
<span class="lolight">  newNumber: function(e) {</span>
<span class="hilight">    this.setState({</span>
<span class="hilight">      randomNumber: this.randomNumber()</span>
<span class="hilight">    });</span>
<span class="lolight">  },</span>
<span class="lolight">  render: function() {</span>
<span class="hilight">    return DOM.div(null,</span>
<span class="hilight">      DOM.h1(null, "Hello World"),</span>
<span class="hilight">      DOM.p({</span>
<span class="hilight">          onClick: this.newNumber</span>
<span class="hilight">        }, "Random number: " + this.state.randomNumber + " (click for another)"),</span>
<span class="hilight">      DOM.textarea(null, "Notes...")</span>
<span class="hilight">    )</span>
<span class="lolight">  }</span>
<span class="lolight">});</span>
</code></pre>

---

# Et Voila!

[Demo of it working?]

---

# What about Backbone Models/Collections?

This is where the power of combining React with Backbone really shines. By leveraging a small mixin we can have React automatically re-render when any model/collection changes, so long as we store it on our `@state`

---

## Backbone Listener

We'll track event listeners via a Backbone.Events object.

```js
function BackboneListener(){}
_.extend(BackboneListener.prototype, Backbone.Events);

var BackboneMixin = {

  getInitialState: function() {
    return {
      _backboneListener: new BackboneListener()
    };
  },
```

---

Hook the relevant lifecycle methods to keep our subscriptions current and avoid leaks.

```js

  componentDidMount: function() {
    this._backboneSubscribeObjects(this.state);
  },

  componentWillUpdate: function(nextProps, nextState) {
    this._backboneUnsubscribeObjects(this.state);
    this._backboneSubscribeObjects(nextState);
  },

  componentWillUnmount: function() {
    this.state._backboneListener.stopListening();
  },

```

---

Here's how subscribing/unsubscribing works:

```js

  _backboneSubscribeObjects: function(props, unsubscribe) {
    var method = (unsubscribe === true ? 'stopListening' : 'listenTo');
    var listener = this.state._backboneListener;

    for (var k in this.props) {
      var obj = this.props[k];

      if (obj instanceof Backbone.Model) {
        listener[method](obj, "change", this._backboneModelUpdate);

      } else if (obj instanceof Backbone.Collection) {
        listener[method](obj, "add remove reset sort change destroy sync", 
          this._backboneCollectionUpdate);
      }
    }
  },

  _backboneUnsubscribeObjects: function(props) {
    this._backboneSubscribeObjects(props, true);
  },

  _backboneModelUpdate: this._forceUpdateOnce,
  _backboneCollectionUpdate: this._forceUpdateOnce,

```

---

For efficiency, we don't call `forceUpdate()` for every single change - instead at most once per runloop.

```js
  _forceUpdateOnce: function() {
    if (this._forceUpdateOnceTimer) return;
    var _this = this;
    this._forceUpdateOnceTimer = setTimeout(function() {
      delete _this._forceUpdateOnceTimer;
      if (_this.isMounted()) {
        return _this.forceUpdate();
      }
    }, 0);
  },
```

**Caveat**: this makes cascading model/collection changes more efficient; *however* the update is not real time. So if you've a managed input element with a Backbone model as source you must call `@forceUpdate()` in your `onChange` handler after updating the model - e.g.,

```js
changedText: function(e) {
  model.set('text', this.refs.text.getDOMNode().value);
  this.forceUpdate(); //<-- VITAL
},
render: function() {
  return DOM.input({ref: 'text', value: @state.model.get('text'), 
                    onChange: @changeText});
}
```

---

Bonus helper methods, in case you want to hook `'sync'` on a collection to refetch a dependent collection or whatever 

```js
  listenTo: function() {
    var listener = this.state._backboneListener;
    return listener.listenTo.apply(listener, arguments);
  },

  stopListening: function() {
    var listener = this.state._backboneListener;
    return listener.stopListening.apply(listener, arguments);
  }
};
```

(Anything you `@listenTo()` will be automatically unsubscribed when your component is unmounted - often this means there's no need to manually call `@stopListening()`.)

---

## Reference it

Simple as adding it to the `mixins` array:

<pre><code class="javascript"><span class="lolight">var HomeView = React.createClass({</span>
<span class="lolight">  displayName: "HomeView",</span>

<span class="hilight">  mixins: [BackboneMixin],</span>

<span class="lolight">  getInitialState: function() {</span>
<span class="lolight">    return {</span>
<span class="lolight">      randomNumber: this.randomNumber()</span>
<span class="lolight">    };</span>
<span class="lolight">  },</span>
<span class="lolight">  //...</span>
<span class="lolight">});</span>
</code></pre>

---

## Just change a backbone model property and everything updates immediately.

<img src="http://operationrainfall.com/wp-content/uploads/2012/06/Happy-Happy-Joy-Joy.jpg">

---

# Moving @props to @state

If you're using a framework (like Rendr) that fetches a bunch of models before creating your top level view, you'll want to move those `@props` over to `@state` so they can be automatically monitored.

Here's how:

---

Keep `@props` Backbone objects sync'd onto `@state`

```js
var BackbonePropsMixin = {
  getInitialState: function() {
    return _.clone(this.props);
  },

  _subscribableObject: (o) {
    return (o instanceof Backbone.Model) || (o instanceof Backbone.Collection);
  }

  componentWillReceiveProps: function(nextProps) {
    var changes = {}, k = null, v = null;
    for (k in nextProps) {
      v = nextProps[k];
      if (this.state[k] !== v && this.props._subscribableObject(v)) {
        changes[k] = v;
      }
    }
    for (k in this.props) {
      v = _ref[k];
      if (this.state[k] === v && !nextProps[k] && 
          this.props._subscribableObject(v)) {
        changes[k] = null;
      }
    }
    return this.setState(changes);
  }
};
```

---

# Don't over-subscribe!

Be careful to only use the former mixin where you have models on your `@state` that you'd like to listen to changes to, and only use the latter mixin on top level components. If you subscribe to the same model in multiple places then React will be forced to redundantly render multiple times in a row due to the use of `@forceRender()` in the mixins.

---

# React is seriously awesome!

- Developing is fun again
- No jQuery spaghetti code
- Simple reusable components
- User interfaces are crazy fast
- No event leaks

---

# Thanks for listening

## Timecounts.org - we're hiring!

### Jof Arnold, VP Product, @jofarnold  
### Benjie Gillam, CTO, @benjie


--></script>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        source: (document.getElementById("source").innerHTML).replace(/^<!--|-->$/g, "")
      });
    </script>
  </body>
</html>
